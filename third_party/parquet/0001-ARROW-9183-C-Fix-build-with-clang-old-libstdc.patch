From a584b57094566dcf32e9b219bc962ab9d0571910 Mon Sep 17 00:00:00 2001
From: Shuai Zhang <zhangshuai.ustc@gmail.com>
Date: Wed, 24 Jun 2020 15:34:00 -0400
Subject: [PATCH] ARROW-9183: [C++] Fix build with clang & old libstdc++.

See https://issues.apache.org/jira/browse/ARROW-9183# for further details & discussion.

Closes #7493 from hcoona/ARROW-9183

Lead-authored-by: Shuai Zhang <zhangshuai.ustc@gmail.com>
Co-authored-by: Shuai Zhang <zhangshuai.ds@bytedance.com>
Signed-off-by: Benjamin Kietzman <bengilgit@gmail.com>
---
 cpp/src/arrow/util/atomic_shared_ptr.h | 64 ++++++++++++++++++++------
 1 file changed, 50 insertions(+), 14 deletions(-)

diff --git a/cpp/src/arrow/util/atomic_shared_ptr.h b/cpp/src/arrow/util/atomic_shared_ptr.h
index 9f3152baf..08f12b351 100644
--- a/cpp/src/arrow/util/atomic_shared_ptr.h
+++ b/cpp/src/arrow/util/atomic_shared_ptr.h
@@ -21,37 +21,73 @@
 #include <memory>
 #include <utility>
 
+#include "arrow/type_traits.h"
+
 namespace arrow {
 namespace internal {
 
-#if !defined(__clang__) && defined(__GNUC__) && __GNUC__ < 5
+// Atomic shared_ptr operations only appeared in libstdc++ since GCC 5,
+// emulate them with unsafe ops if unavailable.
+// See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=57250
+
+template <typename T, typename = void>
+struct is_atomic_load_shared_ptr_available : std::false_type {};
+
+template <typename T>
+struct is_atomic_load_shared_ptr_available<
+    T, void_t<decltype(std::atomic_load(std::declval<const std::shared_ptr<T>*>()))>>
+    : std::true_type {};
+
+template <typename T>
+using enable_if_atomic_load_shared_ptr_available =
+    enable_if_t<is_atomic_load_shared_ptr_available<T>::value, T>;
 
-// atomic shared_ptr operations only appeared in gcc 5,
-// emulate them with unsafe ops on gcc 4.x.
+template <typename T>
+using enable_if_atomic_load_shared_ptr_unavailable =
+    enable_if_t<!is_atomic_load_shared_ptr_available<T>::value, T>;
 
 template <class T>
-inline std::shared_ptr<T> atomic_load(const std::shared_ptr<T>* p) {
-  return *p;
+inline enable_if_atomic_load_shared_ptr_available<std::shared_ptr<T>> atomic_load(
+    const std::shared_ptr<T>* p) {
+  return std::atomic_load(p);
 }
 
 template <class T>
-inline void atomic_store(std::shared_ptr<T>* p, std::shared_ptr<T> r) {
-  *p = r;
+inline enable_if_atomic_load_shared_ptr_unavailable<std::shared_ptr<T>> atomic_load(
+    const std::shared_ptr<T>* p) {
+  return *p;
 }
 
-#else
+template <typename T, typename = void>
+struct is_atomic_store_shared_ptr_available : std::false_type {};
 
-template <class T>
-inline std::shared_ptr<T> atomic_load(const std::shared_ptr<T>* p) {
-  return std::atomic_load(p);
-}
+template <typename T>
+struct is_atomic_store_shared_ptr_available<
+    T, void_t<decltype(std::atomic_store(std::declval<std::shared_ptr<T>*>(),
+                                         std::declval<std::shared_ptr<T>>()))>>
+    : std::true_type {};
+
+template <typename T>
+using enable_if_atomic_store_shared_ptr_available =
+    enable_if_t<is_atomic_store_shared_ptr_available<T>::value, T>;
+
+template <typename T>
+using enable_if_atomic_store_shared_ptr_unavailable =
+    enable_if_t<!is_atomic_store_shared_ptr_available<T>::value, T>;
 
 template <class T>
-inline void atomic_store(std::shared_ptr<T>* p, std::shared_ptr<T> r) {
+inline void atomic_store(
+    enable_if_atomic_store_shared_ptr_available<std::shared_ptr<T>*> p,
+    std::shared_ptr<T> r) {
   std::atomic_store(p, std::move(r));
 }
 
-#endif
+template <class T>
+inline void atomic_store(
+    enable_if_atomic_store_shared_ptr_unavailable<std::shared_ptr<T>*> p,
+    std::shared_ptr<T> r) {
+  *p = r;
+}
 
 }  // namespace internal
 }  // namespace arrow
-- 
2.23.0

